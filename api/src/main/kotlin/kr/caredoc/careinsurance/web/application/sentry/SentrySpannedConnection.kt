package kr.caredoc.careinsurance.web.application.sentry

import io.sentry.Sentry
import java.sql.Blob
import java.sql.CallableStatement
import java.sql.Clob
import java.sql.Connection
import java.sql.DatabaseMetaData
import java.sql.NClob
import java.sql.PreparedStatement
import java.sql.SQLWarning
import java.sql.SQLXML
import java.sql.Savepoint
import java.sql.Statement
import java.sql.Struct
import java.util.Properties
import java.util.concurrent.Executor

@JvmInline
value class SentrySpannedConnection(private val connection: Connection) : Connection {
    override fun <T : Any?> unwrap(iface: Class<T>?): T = connection.unwrap(iface)

    override fun isWrapperFor(iface: Class<*>?) = connection.isWrapperFor(iface)

    override fun close() = connection.close()

    override fun createStatement(): Statement = connection.createStatement()

    override fun createStatement(resultSetType: Int, resultSetConcurrency: Int): Statement =
        connection.createStatement(
            resultSetType,
            resultSetConcurrency,
        )

    override fun createStatement(
        resultSetType: Int,
        resultSetConcurrency: Int,
        resultSetHoldability: Int
    ): Statement = connection.createStatement(
        resultSetType,
        resultSetConcurrency,
        resultSetHoldability,
    )

    override fun prepareStatement(sql: String?): PreparedStatement = connection.prepareStatement(sql)

    override fun prepareStatement(
        sql: String?,
        resultSetType: Int,
        resultSetConcurrency: Int
    ): PreparedStatement = connection.prepareStatement(
        sql,
        resultSetType,
        resultSetConcurrency,
    )

    override fun prepareStatement(
        sql: String?,
        resultSetType: Int,
        resultSetConcurrency: Int,
        resultSetHoldability: Int
    ): PreparedStatement = connection.prepareStatement(
        sql,
        resultSetType,
        resultSetConcurrency,
        resultSetHoldability,
    )

    override fun prepareStatement(sql: String?, autoGeneratedKeys: Int): PreparedStatement =
        connection.prepareStatement(
            sql,
            autoGeneratedKeys,
        )

    override fun prepareStatement(sql: String?, columnIndexes: IntArray?): PreparedStatement =
        connection.prepareStatement(
            sql,
            columnIndexes,
        )

    override fun prepareStatement(sql: String?, columnNames: Array<out String>?): PreparedStatement =
        prepareStatement(
            sql,
            columnNames,
        )

    override fun prepareCall(sql: String?): CallableStatement = connection.prepareCall(sql)

    override fun prepareCall(
        sql: String?,
        resultSetType: Int,
        resultSetConcurrency: Int
    ): CallableStatement = connection.prepareCall(
        sql,
        resultSetType,
        resultSetConcurrency,
    )

    override fun prepareCall(
        sql: String?,
        resultSetType: Int,
        resultSetConcurrency: Int,
        resultSetHoldability: Int
    ): CallableStatement = connection.prepareCall(
        sql,
        resultSetType,
        resultSetConcurrency,
        resultSetHoldability,
    )

    override fun nativeSQL(sql: String?): String = connection.nativeSQL(sql)

    override fun setAutoCommit(autoCommit: Boolean) {
        connection.autoCommit = autoCommit
    }

    override fun getAutoCommit(): Boolean = connection.autoCommit

    override fun commit() {
        val childSpan = Sentry.getSpan()?.startChild("commit")

        try {
            connection.commit()
        } finally {
            childSpan?.finish()
        }
    }

    override fun rollback() {
        val childSpan = Sentry.getSpan()?.startChild("rollback")

        try {
            connection.rollback()
        } finally {
            childSpan?.finish()
        }
    }

    override fun rollback(savepoint: Savepoint?) {
        val childSpan = Sentry.getSpan()?.startChild("rollback")

        try {
            connection.rollback(savepoint)
        } finally {
            childSpan?.finish()
        }
    }

    override fun isClosed(): Boolean = connection.isClosed

    override fun getMetaData(): DatabaseMetaData = connection.metaData

    override fun setReadOnly(readOnly: Boolean) {
        connection.isReadOnly = readOnly
    }

    override fun isReadOnly(): Boolean = connection.isReadOnly

    override fun setCatalog(catalog: String?) {
        connection.catalog = catalog
    }

    override fun getCatalog(): String = connection.catalog

    override fun setTransactionIsolation(level: Int) {
        connection.transactionIsolation = level
    }

    override fun getTransactionIsolation(): Int = connection.transactionIsolation

    override fun getWarnings(): SQLWarning = connection.warnings

    override fun clearWarnings() = connection.clearWarnings()

    override fun getTypeMap(): MutableMap<String, Class<*>> = connection.typeMap

    override fun setTypeMap(map: MutableMap<String, Class<*>>?) {
        connection.typeMap = map
    }

    override fun setHoldability(holdability: Int) {
        connection.holdability = holdability
    }

    override fun getHoldability(): Int = connection.holdability

    override fun setSavepoint(): Savepoint = connection.setSavepoint()

    override fun setSavepoint(name: String?): Savepoint = connection.setSavepoint(name)

    override fun releaseSavepoint(savepoint: Savepoint?) = connection.releaseSavepoint(savepoint)

    override fun createClob(): Clob = connection.createClob()

    override fun createBlob(): Blob = connection.createBlob()

    override fun createNClob(): NClob = connection.createNClob()

    override fun createSQLXML(): SQLXML = connection.createSQLXML()

    override fun isValid(timeout: Int): Boolean = connection.isValid(timeout)

    override fun setClientInfo(name: String?, value: String?) = connection.setClientInfo(name, value)

    override fun setClientInfo(properties: Properties?) {
        connection.clientInfo = properties
    }

    override fun getClientInfo(name: String?): String = connection.getClientInfo(name)

    override fun getClientInfo(): Properties = connection.clientInfo

    override fun createArrayOf(typeName: String?, elements: Array<out Any>?): java.sql.Array =
        connection.createArrayOf(typeName, elements)

    override fun createStruct(typeName: String?, attributes: Array<out Any>?): Struct = connection.createStruct(
        typeName,
        attributes,
    )

    override fun setSchema(schema: String?) {
        connection.schema = schema
    }

    override fun getSchema(): String = connection.schema

    override fun abort(executor: Executor?) {
        connection.abort(executor)
    }

    override fun setNetworkTimeout(executor: Executor?, milliseconds: Int) {
        connection.setNetworkTimeout(executor, milliseconds)
    }

    override fun getNetworkTimeout(): Int = connection.networkTimeout
}
